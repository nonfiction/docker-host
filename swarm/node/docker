#!/bin/bash

# Source once locally if available OR via curl if not 
include() {
  [ -z "$1" ] && return 1
  if [ -e /usr/local/share/platform/swarm/$1 ]; then source /usr/local/share/platform/swarm/$1;
  elif [ -e /root/platform/swarm/$1 ]; then source /root/platform/swarm/$1;
  else source <(curl -fsSL https://github.com/nonfiction/platform/raw/main/swarm/$1); fi
}

# Bash helper functions
include "lib/helpers.sh"


# DRAIN DOCKER SWARM (run on manager)
# ----------------------------------------
if defined $DRAIN && defined $NODE; then

  # Drain the node before reboot 
  echo_run "docker node update --availability=drain ${NODE}"


# DRAIN DOCKER SWARM (run on manager)
# ----------------------------------------
elif defined $ACTIVE && defined $NODE; then

  # Restore the node to active after reboot 
  echo_run "docker node update --availability=active ${NODE}"


# PROMOTE DOCKER SWARM (run on manager)
# ----------------------------------------
elif defined $PROMOTE && defined $NODE; then

  # Run on primary node to promote a worker to manager
  echo_run "docker node promote ${NODE}"
  sleep 1


# DEMOTE DOCKER SWARM (run on manager)
# ----------------------------------------
elif defined $DEMOTE && defined $NODE; then

  # Run on primary node to demote manager (it's probably only a worker, but just in case)
  echo_run "docker node demote ${NODE}"
  sleep 5


# DEMOTE DOCKER SWARM (run on worker)
# ----------------------------------------
elif defined $LEAVE; then

  # Run on replica node to leave the swarm
  echo_run "docker swarm leave"
  sleep 5


# DEMOTE DOCKER SWARM (run on manager)
# ----------------------------------------
elif defined $REMOVE && defined $NODE; then

  # Run on primary node to remove worker node
  echo_run "docker node rm --force ${NODE}"


# JOIN/INIT DOCKER SWARM (run on each node)
# ----------------------------------------
elif defined $JOIN && defined $NODE && defined $JOIN_TOKEN && defined $PRIVATE_IP; then

  # Primary node - create swarm
  if [ "$JOIN_TOKEN" = "primary" ]; then

    if [ "$(docker info --format '{{.Swarm.LocalNodeState}}')" != "active" ]; then
      echo_next "Initializing swarm mode [${NODE}]"
      echo "docker swarm init --advertise-addr $PRIVATE_IP"
      docker swarm init --advertise-addr $PRIVATE_IP
    else
      echo_info "Swarm mode is already active for primary [${NODE}]"
    fi

    echo_next "Writing token to /etc/docker-join-token"
    echo "$(docker swarm join-token worker | grep docker | awk '{print $5, $6}')" | tee /etc/docker-join-token

  # Replica node - join swarm
  else

    if [ "$(docker info --format '{{.Swarm.LocalNodeState}}')" != "active" ]; then
      echo_next "Joining swarm as worker [${NODE}]"
      echo "docker swarm join --token $JOIN_TOKEN"
      docker swarm join --token $JOIN_TOKEN
    else
      echo_info "Swarm mode is already active for replica [${NODE}]"
    fi

  fi


# SECRETS (run on manager)
# ----------------------------------------
elif defined $SECRETS && defined $ROOT_PRIVATE_KEY && defined $ROOT_PASSWORD && defined $DO_AUTH_TOKEN; then

  # Create dotenv file
  dotenv="/root/platform/.env"
  echo_next "Writing ${dotenv}"
  echo "" > $dotenv
  echo "SWARM=$(cat /etc/swarm)" | tee --append $dotenv
  echo "NODE=$(cat /etc/node)" | tee --append $dotenv

  # Create or update docker secrets
  set_secret() {

    local env_name="${1}"
    local env_value="${!1}"
    local secret_name="$(echo $name | tr '[:upper:]' '[:lower:]')"
    local secret_name_new="${secret_name}_new"

    # Skip if there's no value
    undefined "$env_value" && return

    # Doesn't yet exist? Easy, just add the secret
    if undefined "$(docker secret ls | grep " $secret_name ")"; then
      echo -n "${env_value}" | docker secret create $secret_name -

    # Update the secret...
    else

      # Create a new secret with a similar name
      echo "docker secret create ${secret_name_new}"
      echo -n "${env_value}" | docker secret create $secret_name_new -

      # Remove the old secret from all services while adding the new one
      for service in ${@:2}; do
        echo_run "docker service update --detach=false --secret-rm ${secret_name} --secret-add source=${secret_name_new},target=${secret_name} nf_${service}"
      done

      # Remove the old secret
      echo_run "docker secret rm ${secret_name}"

      # Create the old secret again with the new value
      echo "docker secret create ${secret_name}"
      echo -n "${env_value}" | docker secret create $secret_name -

      # Remove the new secret from all services while adding the old one again
      for service in ${@:2}; do
        echo_run "docker service update --detach=false --secret-rm ${secret_name_new} --secret-add source=${secret_name},target=${secret_name} nf_${service}"
      done

    fi
  }

  echo_next "Setting docker secrets"

  set_secret DO_AUTH_TOKEN traefik workspace
  set_secret ROOT_PRIVATE_KEY traefik workspace
  set_secret ROOT_PASSWORD workspace

  set_secret DROPLET_IMAGE workspace
  set_secret REGION workspace
  set_secret FS_TYPE workspace

  set_secret CODE_PASSWORD workspace
  set_secret SUDO_PASSWORD workspace

  set_secret BASICAUTH_USER workspace
  set_secret BASICAUTH_PASSWORD workspace

  set_secret GIT_USER_NAME workspace
  set_secret GIT_USER_EMAIL workspace
  set_secret GITHUB_USER workspace
  set_secret GITHUB_TOKEN workspace

  set_secret WEBHOOK workspace

  set_secret DB_USER workspace
  set_secret DB_HOST workspace
  set_secret DB_PASSWORD workspace
  set_secret DB_PORT workspace


# STACK
# ----------------------------------------
# elif defined $STACK && defined $CERTS && defined $DASHBOARDS && defined $DO_AUTH_TOKEN; then
elif defined $STACK && defined $NODES && defined $DO_AUTH_TOKEN; then

  # Create a comma-separated list of hostnames for traefik configs
  build_hosts() {
    local domain=$(cat /etc/domain)
    local hosts=""
    for node in $NODES; do
      hosts+=",\`${1}.${node}.${domain}\`"
    done
    echo "${hosts:1}"
  }

  # Build domain certs config for traefik yaml
  build_domains() {
    local domain=$(cat /etc/domain)
    local domains="" i=0 n="\n        " # new line & 8 spaces
    for node in $NODES; do
      domains+="${n}traefik.http.routers.wildcard-certs.tls.domains[${i}].main: \"${node}.${domain}\""
      domains+="${n}traefik.http.routers.wildcard-certs.tls.domains[${i}].sans: \"*.${node}.${domain}\""
      ((i++))
    done
    echo "$domains"
  }


  # Create traefik stack
  stack="/root/platform/traefik.yml"
  echo_next "Writing ${stack}"
  curl -sL https://github.com/nonfiction/platform/raw/main/stack-traefik.yml > $stack
  sed -i "s/__HOSTS__/$(build_hosts "traefik")/" $stack
  sed -i "s/__DOMAINS__/$(build_domains)/" $stack
  sed -i "s/__PRIMARY_IP__/$(cat /etc/primary_ip)/" $stack
  sed -i "s/__DO_AUTH_TOKEN__/${DO_AUTH_TOKEN}/" $stack
  echo_run "docker pull nonfiction/traefik"

  # Create hello-world stack
  stack="/root/platform/hello-world.yml"
  echo_next "Writing ${stack}"
  curl -sL https://github.com/nonfiction/platform/raw/main/stack-hello-world.yml > $stack
  sed -i "s/__HOSTS__/$(build_hosts "hello-world")/" $stack
  echo_run "docker pull nonfiction/hello-world"


  # Create portainer stack
  stack="/root/platform/portainer.yml"
  echo_next "Writing ${stack}"
  curl -sL https://github.com/nonfiction/platform/raw/main/stack-portainer.yml > $stack
  sed -i "s/__HOSTS__/$(build_hosts "portainer")/" $stack
  echo_run "docker pull portainer/portainer-ce"


  # Create workspace stack
  stack="/root/platform/workspace.yml"
  echo_next "Writing ${stack}"
  curl -sL https://github.com/nonfiction/platform/raw/main/stack-workspace.yml > $stack
  sed -i "s/__HOSTS__/$(build_hosts "workspace")/" $stack
  sed -i "s/__SWARM__/$(cat /etc/swarm)/" $stack
  echo_run "docker pull nonfiction/workspace"


fi

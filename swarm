#!/bin/bash

# Bash helper functions
if [ -e lib/helpers.sh ]; then source lib/helpers.sh;
else source <(curl -fsSL https://github.com/nonfiction/platform/raw/master/lib/helpers.sh); fi

# Digital Ocean API functions
if [ -e lib/doctl.sh ]; then source lib/doctl.sh;
else source <(curl -fsSL https://github.com/nonfiction/platform/raw/master/lib/doctl.sh); fi


# First parameter is name of swarm and primary node
PRIMARY="$1"
if undefined $PRIMARY; then
  echo_stop "Missing swarm name!"
  echo "The first argument for this script should be the swarm's name. Example: ./swarm app 3"
  exit 1
fi

# Second parameter is number of additions, or default 0
ADDITIONS="$(get_droplet_additions $1 $2)"

# Look up number of existing replicas from $PRIMARY name, single node swarm is 0
REPLICAS="$(echo "$(get_droplet_replicas $1) $ADDITIONS" | tr ' ' '\n' | sort | uniq | xargs)"

# If primary doesn't exist yet, count that as an addition
has_droplet $PRIMARY || ADDITIONS="$(echo "$PRIMARY $ADDITIONS" | xargs)"

# Count the number of nodes in this swarm
count=$((1 + $(echo $REPLICAS | wc -w)))
[ "$count" = "1" ] && count="Single"


echo_env "${count}-node swarm..."
echo_env PRIMARY
echo_env REPLICAS
echo_env ADDITIONS

echo_next "Configuration..."
echo_env DROPLET_IMAGE
echo_env DROPLET_SIZE
echo_env VOLUME_SIZE
echo_env FS_TYPE
echo_env REGION
echo_env ROOT_PASSWORD
echo_env ROOT_PRIVATE_KEY 30
echo_env ROOT_PUBLIC_KEY 30

if ask "Process droplets in the swarm?"; then  
  echo_next "Beginning..."
else
  echo_stop "Cancelled."  
  exit 1;
fi

# Swarm name matches the name of the primary node
swarm_name=$PRIMARY

# First node processed has a primary role
role="primary"

# Make sure this file doesn't yet exist
rm -f /tmp/dirty.txt

for node_name in $(echo "$PRIMARY $REPLICAS" | xargs); do
  
  echo_node_header  $node_name $role
  echo_droplet_info $node_name
  echo_volume_info  $node_name
  echo_record_info  $node_name

  if has /tmp/dirty.txt; then 
    if ask "Process droplet?"; then
      
      # First create/resize the volume that will be attached
      create_or_resize_volume $node_name $swarm_name $role
      
      # Then create/resize the droplet itself
      create_or_resize_droplet $node_name $swarm_name $role
      
      # Last, ensure the DNS records are pointing to this droplet
      public_ip="$(get_droplet_public_ip $node_name)"
      create_or_update_record "${node_name}" $public_ip
      create_or_update_record "*.${node_name}" $public_ip
      
    fi
  fi  
  
  # Clear out this file
  rm -f /tmp/dirty.txt
  
  role="replica"
done


if ask "Run configuration on each node in swarm?"; then  
  echo_next "Beginning..."
else
  echo_stop "Cancelled."  
  exit 1;
fi

# All available nodes in this swarm
nodes="$PRIMARY $(get_droplet_replicas $swarm_name)"


# ---------------------------------------------------------
# System configuration for each node
# ---------------------------------------------------------

# Build hosts file
hosts="127.0.0.1 localhost"
for name in $nodes; do
  ip="$(get_droplet_private_ip $name)"
  hosts="${hosts}\n${ip} ${name}"
done

# Loop all nodes in swarm
for name in $nodes; do
  
  ip="$(get_droplet_public_ip $name)"
  
  # Update password (once)
  run $ip "if [ ! -e /etc/password_updated ]; then echo root:${ROOT_PASSWORD} | chpasswd && echo work:${ROOT_PASSWORD} | chpasswd && touch /etc/password_updated; fi"
  
  echo_next "Updating /etc/hosts on $name"
  hosts_self="127.0.1.1 ${name}.${DOMAIN} $name"
  run $ip "echo -e \"${hosts_self}\n${hosts}\" > /etc/hosts" 
  
  echo_next "Updating authorized_keys on $name"
  keys="$(curl -sL https://github.com/nonfiction/workspace/raw/main/config/ssh/authorized_keys)"
  keys=$(echo -e "${ROOT_PUBLIC_KEY}\n${keys}")
  run $ip "echo \"$keys\" > /root/.ssh/authorized_keys"
  run $ip "echo \"$keys\" > /work/.ssh/authorized_keys"

done  
  

# stop here for now
exit

# ---------------------------------------------------------
# Create Docker Swarm and join workers
# ---------------------------------------------------------

# Loop all nodes in swarm
docker_swarm_join="docker info"
for name in $nodes; do
  
  ip="$(get_droplet_public_ip $name)"

  run $ip "$docker_swarm_join"
  wait_for docker
  
  if [ "$name" = "$PRIMARY" ]; then
    private_ip="$(get_droplet_private_ip $name)"
    run $ip "docker swarm init --advertise-addr $private_ip"
    docker_swarm_join=$(run $ip "docker swarm join-token worker | grep docker")
    
  else
    run $ip "$docker_swarm_join"
  fi
  
done


# ---------------------------------------------------------
# Create Gluster Volume
# ---------------------------------------------------------

# Loop all nodes in swarm
for name in $nodes; do
  
  ip="$(get_droplet_public_ip $name)"
  
  wait_for gluster
  
  if [ "$name" = "$PRIMARY" ]; then
  
    # GlusterFS probe nodes  
    for n in $nodes; do
      [ "$n" = "$PRIMARY" ] || run $ip "gluster peer probe $n"
    done
    run $ip "gluster pool list"
    
    # gluster volume create work-gfs replica 3 goof:/work goof01:/work goof02:/work force
    # gluster volume start work-gfs
    
    # echo 'localhost:/work-gfs /work glusterfs defaults,_netdev,backupvolfile-server=localhost 0 0' >> /etc/fstab

    # mount.glusterfs localhost:/work-gfs /work

    #chown -R root:docker /mnt
    
  else
    echo 
  fi
  
  echo
  echo
done
  


exit 0
